#!/usr/bin/env python3
"""Relay–Choir Puzzle — generator, solver **and Tk GUI with options**
-----------------------------------------------------------------
Author  : ChatGPT (OpenAI o3)
Version : 2025‑07‑23  (unique-path barricades, legend help text, size selector,
           node counter)
Python  : 3.10+   (no external libraries)

Run modes
~~~~~~~~~
* GUI  (default)   –  `python puzzle.py`
* CLI               –  `python puzzle.py cli 6 12345`  (size 6, seed 12345)
* Self‑tests        –  `python puzzle.py test`
"""
from __future__ import annotations

import argparse
import heapq
import random
import string
import sys
import time
import tkinter as tk
from dataclasses import dataclass, field
from enum import Enum
from typing import Dict, List, Optional, Set, Tuple

# ─────────────────────────────────────────────────────────────────────────────
#  Board primitives
# ─────────────────────────────────────────────────────────────────────────────
class Cell(Enum):
    EMPTY = "·"
    ENTR  = "E"
    RELAY = "R"
    CHOIR = "C"
    STATN = "S"
    SUN   = "O"
    FUEL  = "F"
    WARP  = "W"
    SAT   = "T"
    BARRI = "B"   # barricade placed by generator to force uniqueness

# 8‑direction neighbour offsets (Chebyshev grid)
DIRS8: List[Tuple[int, int]] = [
    (dx, dy)
    for dx in (-1, 0, 1)
    for dy in (-1, 0, 1)
    if (dx, dy) != (0, 0)
]

# Chebyshev distance (max norm)
def cheb(a: Tuple[int, int], b: Tuple[int, int]) -> int:
    return max(abs(a[0] - b[0]), abs(a[1] - b[1]))

# type alias for coordinates
Loc = Tuple[int, int]


@dataclass(order=True, frozen=True, slots=True)
class State:
    sort: int = field(init=False, compare=True, repr=False)
    loc: Loc
    relay1: bool
    station: bool
    choir: bool
    relay2: bool
    fuel: bool
    t1: int

    def with_sort(self, g: int) -> "State":
        object.__setattr__(self, "sort", g)
        return self


# ─────────────────────────────────────────────────────────────────────────────
#  Puzzle (generator + solver)
# ─────────────────────────────────────────────────────────────────────────────
class Puzzle:
    def __init__(self, size: int, seed: Optional[int], *, want_station: bool, want_sat: bool):
        self.n = size
        self.history = 2               # how many last squares to include in A* state key
        self.nodes_expanded = 0        # for debug stats

        self.rng = random.Random(seed)
        # if no seed supplied, pick one and re-seed RNG with it for reproducibility
        self.seed = seed if seed is not None else self.rng.randint(0, 1_000_000)
        if seed is None:
            self.rng.seed(self.seed)

        t0 = time.perf_counter()
        tries = 0
        while True:
            self._fresh_board(want_station, want_sat)
            sol, span = self._ensure_unique()
            if sol is not None:
                # ensure_unique already ran a final normal _solve so the helper
                # members (self.turns, self.solution_flat, self.turn_actions) are set.
                self.solution = sol
                self.span = span
                break
            tries += 1
            if tries > 100:
                raise RuntimeError("Couldn't get unique board after 100 attempts")
        self.gen_time = time.perf_counter() - t0
        self.gen_tries = tries + 1

    # ---------- placement ----------------------------------------------------
    def _fresh_board(self, want_station: bool, want_sat: bool) -> None:
        self.grid: List[List[Cell]] = [[Cell.EMPTY] * self.n for _ in range(self.n)]

        self.entr   = self._rand(Cell.ENTR)
        self.relay  = self._rand(Cell.RELAY)
        self.choir  = self._rand(Cell.CHOIR)
        self.station = self._rand(Cell.STATN) if want_station else None
        self.sat     = self._rand(Cell.SAT)   if want_sat    else None
        self.sun    = self._rand(Cell.SUN)
        self.fuel   = self._rand(Cell.FUEL)

        wcnt = 1 + self.rng.randint(0, self.n - 4)
        self.warps = [self._rand(Cell.WARP) for _ in range(wcnt)]

        bcnt = 1 + self.rng.randint(0, self.n // 2)   # 1–3 on size 5, scales a bit
        self.barrics = [self._rand(Cell.BARRI) for _ in range(bcnt)]

    def _rand(self, cell: Cell) -> Loc:
        while True:
            x, y = self.rng.randrange(self.n), self.rng.randrange(self.n)
            if self.grid[y][x] is Cell.EMPTY:
                self.grid[y][x] = cell
                return (x, y)

    # ------------------------------------------------------------------
    # Force exactly one optimal solution (shortest number of turns) by
    # inserting barricades at divergence points if needed.
    # ------------------------------------------------------------------
    def _ensure_unique(self) -> Tuple[Optional[List[List[Loc]]], Optional[int]]:
        for _ in range(30):  # cap the number of edits so we never loop forever
            paths, span = self._solve(want_two=True)  # collect ≤2 shortest paths
            if paths is None:                         # unsolvable board
                break

            if len(paths) == 1:
                # Finalize: run once more in normal mode to populate helpers
                self._solve(want_two=False)
                return self.turns, span

            if len(paths) == 2:
                p1, p2 = paths
                # locate first turn where they differ
                for t in range(1, min(len(p1), len(p2))):
                    if p1[t] != p2[t]:
                        bx, by = p2[t][-1]  # pick square from second path
                        break
                else:
                    # shouldn't happen, but bail out and regenerate
                    break

                if self.grid[by][bx] is Cell.EMPTY:
                    self.grid[by][bx] = Cell.BARRI  # insert barricade
                    continue                        # re-solve

            # more than two equal-length paths or couldn't place barricade → give up
            break

        return None, None  # tell caller to regenerate whole board

    # ---------- helpers ------------------------------------------------------
    def cell(self, l: Loc) -> Cell:
        return self.grid[l[1]][l[0]]

    def in_bounds(self, l: Loc) -> bool:
        return 0 <= l[0] < self.n and 0 <= l[1] < self.n

    def passable(self, l: Loc) -> bool:
        return self.cell(l) not in {Cell.SUN, Cell.WARP, Cell.BARRI}

    def adj(self, l: Loc) -> List[Loc]:
        x, y = l
        return [(x + dx, y + dy) for dx, dy in DIRS8 if self.in_bounds((x + dx, y + dy))]

    def speed(self, l: Loc, fuel: bool) -> int:
        s = 1 + (1 if fuel else 0)
        if cheb(l, self.sun) == 1:
            s += 1
        if any(cheb(l, w) == 1 for w in self.warps):
            s = max(1, s - 1)
        return min(s, 3)

    # ─────────────────────────── solver ────────────────────────────
    def _solve(self, want_two: bool = False):
        """
        A* search.  If `want_two=True` it collects up to **two** distinct
        shortest‑length solutions and returns them; otherwise it returns the
        first one it finds and also builds helper members (`self.turns`,
        `self.solution_flat`, `self.turn_actions`).

        Return value:
            * unique‑path mode (want_two=False):
                  (turns, relay_span)
            * two‑path mode  (want_two=True):
                  ([turns1], relay_span)          # exactly one path
               or ([turns1, turns2], relay_span)  # two distinct paths
            * if unsolved: (None, None)
        """
        need_stat = self.station is not None

        best_len: Optional[int] = None     # number of turns of the first solution
        best_paths: List[List[List[Loc]]] = []  # collect up to two paths

        def h(loc: Loc) -> int:
            return cheb(loc, self.entr)   # admissible heuristic back to entrance

        start = State(self.entr, False, False, False, False, False, -1).with_sort(0)
        pq = [(h(self.entr), 0, 0, start, (self.entr,), [[self.entr]])]
        best_g: Dict[Tuple[State, Tuple[Loc, ...]], int] = {(start, (self.entr,)): 0}
        best_span = 0
        expanded = 0

        while pq:
            f, g, span, st, flat, turns = heapq.heappop(pq)
            expanded += 1

            # goal check
            if (st.loc == self.entr and st.relay2 and st.choir and
                    (st.station or not need_stat)):
                if best_len is None:
                    best_len = g
                    best_span = span
                if g == best_len:
                    best_paths.append(turns)
                    if not want_two:
                        break
                    if len(best_paths) == 2:
                        break
                continue

            # cut search after shortest path is known
            if best_len is not None and g >= best_len:
                continue

            # expand one *turn* (sequence up to speed squares)
            spd = self.speed(st.loc, st.fuel)
            for seq in self._seqs(st.loc, spd):
                dest = seq[-1]
                cell = self.cell(dest)

                # copy flags
                r1, r2 = st.relay1, st.relay2
                cho, sta = st.choir, st.station
                fu = st.fuel or cell == Cell.FUEL
                t1 = st.t1

                def in_r(obj: Loc) -> bool:
                    if dest == obj:
                        return True
                    return (self.sat and
                            cheb(self.sat, obj) == 1 and
                            cheb(dest, obj) <= 1)

                if in_r(self.relay):
                    if not r1:
                        r1, t1 = True, g + 1
                    elif cho and not r2:
                        r2 = True
                if self.station and in_r(self.station):
                    sta = True
                if in_r(self.choir) and r1 and sta == need_stat:
                    cho = True

                ng = g + 1
                nspan = (ng - t1) if r1 and not r2 else span
                ns = State(dest, r1, sta, cho, r2, fu, t1).with_sort(ng)

                new_flat = flat + tuple(seq)
                key = (ns, new_flat[-self.history:])
                if key in best_g and ng >= best_g[key]:
                    continue
                best_g[key] = ng

                nf = ng + h(dest)
                new_turns = turns + [seq]
                heapq.heappush(pq, (nf, ng, nspan, ns, new_flat, new_turns))

        # record metric for GUI
        self.nodes_expanded = expanded

        if not best_paths:
            return None, None

        if want_two:
            return best_paths, best_span

        # Normal mode → store helper info
        self.turns = best_paths[0]
        self.solution_flat = [sq for turn in self.turns for sq in turn]

        # Build per‑turn action notes
        self.turn_actions: List[str] = []
        r1 = r2 = sta = cho = False
        for seq in self.turns[1:]:  # skip entrance
            dest = seq[-1]
            act: List[str] = []
            if dest == self.relay and not r1:
                act.append("Relay ON"); r1 = True
            elif dest == self.relay and r1 and cho and not r2:
                act.append("Relay OFF"); r2 = True
            if (self.station and not sta and
                (dest == self.station or
                 (self.sat and cheb(self.sat, self.station) == 1 and
                  cheb(dest, self.station) <= 1))):
                act.append("Station handshake"); sta = True
            if dest == self.choir and r1 and sta and not cho:
                act.append("Choir ping"); cho = True
            self.turn_actions.append("Action: " + ", ".join(act) if act else "Action: –")

        return self.turns, best_span

    # ---------- sub‑step enumerator -----------------------------------------
    def _seqs(self, start: Loc, spd: int) -> List[List[Loc]]:
        """Enumerate every distinct sequence of 1…spd adjacent moves (no repeats)."""
        paths = [[start]]
        finals: List[List[Loc]] = []
        for _ in range(spd):
            nxt = []
            for p in paths:
                for nb in self.adj(p[-1]):
                    if not self.passable(nb) or nb in p:
                        continue
                    new = p + [nb]
                    nxt.append(new)
                    finals.append(new[1:])  # drop starting square
            paths = nxt
        return finals

    # ---------- pretty helpers ----------------------------------------------
    def to_coord(self, l: Loc) -> str:
        return f"{string.ascii_uppercase[l[1]]}{l[0] + 1}"

    def pretty(self, hl: Optional[Set[Loc]] = None) -> str:
        lines = ["   " + " ".join(str(i + 1) for i in range(self.n))]
        for y in range(self.n):
            row = [self.grid[y][x].value for x in range(self.n)]
            if hl:
                for x in range(self.n):
                    if (x, y) in hl:
                        row[x] = "*"
            lines.append(f"{string.ascii_uppercase[y]}  " + " ".join(row))
        return "\n".join(lines)


# ─────────────────────────────────────────────────────────────────────────────
#  Colours & legend labels  (module‑level constants)
# ─────────────────────────────────────────────────────────────────────────────
CELL_COLORS: Dict[Cell, str] = {
    Cell.EMPTY: "#FFFFFF",
    Cell.ENTR : "#00AAFF",
    Cell.RELAY: "#FFD700",
    Cell.CHOIR: "#FF66CC",
    Cell.STATN: "#7DFF7D",
    Cell.SUN  : "#FFA500",
    Cell.FUEL : "#B19CD9",
    Cell.WARP : "#000000",
    Cell.SAT  : "#B0B0B0",
    Cell.BARRI: "#A57240",
}

SYMBOL_LABELS: Dict[Cell, str] = {
    c: f"{c.name.title()} ({c.value})" for c in Cell if c is not Cell.EMPTY
}
SYMBOL_HELP: Dict[Cell, str] = {
    Cell.ENTR : "Your ship’s start / home square.",
    Cell.RELAY: "Toggle ON first; later OFF to finish.",
    Cell.CHOIR: "Ping after relay ON (and station, if present).",
    Cell.STATN: "Handshake required before choir ping.",
    Cell.SUN  : "Adjacent gives +1 speed (tile itself is blocked).",
    Cell.FUEL : "Permanently +1 speed after visiting.",
    Cell.WARP : "Adjacent slows you (–1 speed). Tile is blocked.",
    Cell.SAT  : "Extends relay/station range by 1 square.",
    Cell.BARRI: "Wall placed by generator to force unique path.",
}

# order in legend (skip EMPTY)
LEGEND_ORDER = [Cell.ENTR, Cell.RELAY, Cell.CHOIR, Cell.STATN, Cell.SUN,
                Cell.FUEL, Cell.WARP, Cell.SAT, Cell.BARRI]


# ─────────────────────────────────────────────────────────────────────────────
#  CLI mode
# ─────────────────────────────────────────────────────────────────────────────

def cli_mode(size: int, seed: Optional[int], opts: Dict[str, bool]) -> None:
    p = Puzzle(size, seed, **opts)
    print(f"Seed: {p.seed}\n")
    print(p.pretty(set(p.solution_flat)))
    print()
    for idx, (seq, act) in enumerate(zip(p.turns[1:], p.turn_actions), 1):
        start_sq = p.turns[idx - 1][-1]
        path = " → ".join(p.to_coord(l) for l in [start_sq, *seq])
        print(f"Turn {idx}:")
        print(path)
        print(act)
        print()
    print(f"Total moves: {len(p.turns) - 1}, relay span: {p.span}")


# ─────────────────────────────────────────────────────────────────────────────
#  GUI
# ─────────────────────────────────────────────────────────────────────────────
class PuzzleGUI(tk.Tk):
    TILE = 42
    PAD = 8
    FONT = ("Courier New", 16, "bold")

    def __init__(self):
        super().__init__()
        self.title("Relay–Choir Puzzle")
        # control variables
        self.size_var   = tk.IntVar(value=5)
        self.seed_var   = tk.StringVar()
        self.show_sol   = tk.BooleanVar()
        self.station_var= tk.BooleanVar(value=True)
        self.sat_var    = tk.BooleanVar(value=True)
        self._build()
        self._new()

    # -------------------- UI build --------------------
    def _build(self):
        frm = tk.Frame(self)
        frm.pack(padx=10, pady=10)

        # legend
        leg = tk.Frame(frm)
        leg.grid(row=0, column=0, sticky="nw")
        tk.Label(leg, text="Legend", font=("Arial", 12, "bold")).pack(anchor="w")
        for cell in LEGEND_ORDER:
            label = SYMBOL_LABELS[cell]
            row = tk.Frame(leg)
            row.pack(anchor="w", pady=(0, 0))
            tk.Canvas(row, width=18, height=18, bg=CELL_COLORS[cell],
                      highlightthickness=1).pack(side="left")
            tk.Label(row, text=" " + label).pack(side="left")
            # description line (wrapped)
            desc = SYMBOL_HELP.get(cell, "")
            if desc:
                tk.Label(leg, text="    " + desc, fg="#666",
                         font=("Arial", 9), wraplength=220, justify="left").pack(anchor="w")

        # canvas (board)
        self.canvas = tk.Canvas(frm, bg="#EFEFEF")
        self.canvas.grid(row=0, column=1, padx=self.PAD)

        # right controls
        right = tk.Frame(frm)
        right.grid(row=0, column=2, sticky="n")
        tk.Label(right, text="Seed").pack(pady=(6, 0))
        tk.Entry(right, width=8, textvariable=self.seed_var).pack()

        tk.Label(right, text="Size").pack(pady=(6, 0))
        tk.Spinbox(right, from_=5, to=9, width=3, textvariable=self.size_var,
                   command=self._new).pack()

        tk.Button(right, text="Generate", command=self._new).pack(pady=4)
        tk.Checkbutton(right, text="Include station (S)", variable=self.station_var,
                       command=self._new).pack(anchor="w")
        tk.Checkbutton(right, text="Include satellite (T)", variable=self.sat_var,
                       command=self._new).pack(anchor="w")
        tk.Checkbutton(right, text="Show solution", variable=self.show_sol,
                       command=self._draw).pack(pady=(6, 0))

        tk.Label(right, text=" Solution coords ").pack(pady=(10, 0))
        self.sol_box = tk.Text(right, width=36, height=20, state="disabled",
                               font=("Consolas", 10))
        self.sol_box.pack()

        self.stats_lbl = tk.Label(right, font=("Consolas", 10))
        self.stats_lbl.pack(pady=(4, 0))

        self.debug_lbl = tk.Label(right, font=("Consolas", 9), fg="#555")
        self.debug_lbl.pack(pady=(6, 0))

    # -------------------- generation --------------------
    def _new(self):
        size = self.size_var.get()
        seed_text = self.seed_var.get()
        seed = int(seed_text) if seed_text.strip() else None
        opts = dict(want_station=self.station_var.get(), want_sat=self.sat_var.get())
        self.puz = Puzzle(size, seed, **opts)
        self.seed_var.set(str(self.puz.seed))
        self._draw()

    # -------------------- drawing --------------------
    def _draw(self):
        n = self.puz.n
        self.canvas.config(width=n * self.TILE + self.PAD * 2,
                           height=n * self.TILE + self.PAD * 2 + 20)
        self.canvas.delete("all")

        # tiles
        for y in range(n):
            for x in range(n):
                x0 = self.PAD + x * self.TILE
                y0 = self.PAD + y * self.TILE + 20
                c = self.puz.grid[y][x]
                self.canvas.create_rectangle(x0, y0, x0 + self.TILE, y0 + self.TILE,
                                              fill=CELL_COLORS[c], outline="#777")
                self.canvas.create_text(x0 + self.TILE / 2, y0 + self.TILE / 2,
                                         text=c.value, font=self.FONT)

        # headers
        for x in range(n):
            self.canvas.create_text(self.PAD + x * self.TILE + self.TILE / 2,
                                     self.PAD + 10, text=str(x + 1))
        for y in range(n):
            self.canvas.create_text(self.PAD * 0.5,
                                     self.PAD + y * self.TILE + 20 + self.TILE / 2,
                                     text=string.ascii_uppercase[y])

        coords_txt = stats_txt = ""
        if self.show_sol.get():
            flat = self.puz.solution_flat
            # arrow path
            for i in range(len(flat) - 1):
                x1, y1 = flat[i]
                x2, y2 = flat[i + 1]
                self.canvas.create_line(
                    self.PAD + x1 * self.TILE + self.TILE / 2,
                    self.PAD + y1 * self.TILE + 20 + self.TILE / 2,
                    self.PAD + x2 * self.TILE + self.TILE / 2,
                    self.PAD + y2 * self.TILE + 20 + self.TILE / 2,
                    width=3, smooth=True, arrow="last",
                )

            # per‑turn listing
            lines: List[str] = []
            for idx, (seq, act) in enumerate(zip(self.puz.turns[1:], self.puz.turn_actions), 1):
                start_sq = self.puz.turns[idx - 1][-1]
                path = " → ".join(self.puz.to_coord(l) for l in [start_sq, *seq])
                lines.append(f"Turn {idx}:")
                lines.append(path)
                lines.append(act)
                lines.append("")
            coords_txt = "\n".join(lines)

            stats_txt = (
                f"Total moves: {len(self.puz.turns) - 1}\n"
                f"Relay span: {self.puz.span}"
            )

        # update right panels
        self.sol_box.config(state="normal")
        self.sol_box.delete("1.0", tk.END)
        self.sol_box.insert(tk.END, coords_txt)
        self.sol_box.config(state="disabled")

        self.stats_lbl.config(text=stats_txt)
        dbg = (
            f"gen   {self.puz.gen_time*1000:.1f} ms\n"
            f"tries {self.puz.gen_tries}\n"
            f"nodes {self.puz.nodes_expanded}\n"
            f"size  {self.puz.n} (H={self.puz.history})"
        )
        self.debug_lbl.config(text=dbg)


# -------------------- tests & main --------------------

def run_tests() -> None:
    for size, seed in [(5, 123), (7, 456)]:
        p = Puzzle(size, seed, want_station=True, want_sat=True)
        assert p.turns and p.span >= 0
    print("Self‑tests passed ✔")


def main() -> None:
    parser = argparse.ArgumentParser(description="Relay–Choir Puzzle utility")
    parser.add_argument("mode", nargs="?", choices=["gui", "cli", "test"], default="gui")
    parser.add_argument("size", nargs="?", type=int)
    parser.add_argument("seed", nargs="?", type=int)
    parser.add_argument("--no-station", action="store_true")
    parser.add_argument("--no-sat", action="store_true")
    args = parser.parse_args()

    if args.mode == "test":
        run_tests()
    elif args.mode == "cli":
        sz = args.size or 5
        seed = args.seed
        opts = dict(want_station=not args.no_station, want_sat=not args.no_sat)
        cli_mode(sz, seed, opts)
    else:
        PuzzleGUI().mainloop()


if __name__ == "__main__":
    main()
